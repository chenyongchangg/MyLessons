

#### 数据库索引优化方法

```
索引不是越多越好 按照查询需求建索引
索引列要尽量不同 不然成链表了
```



> 索引（Index）是帮助数据库高效获取数据的数据结构。

#### 数据库引擎

MYISAM和INNODB的差别

```c
1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
2. InnoDB 支持外键，而 MyISAM 不支持。对一个包含外键的 InnoDB 表转为 MYISAM 会失败；  
3. InnoDB 是聚簇索引，MyISAM 是非聚簇索引。聚簇索引的文件存放在主键索引的叶子节点上，因此 InnoDB 必须要有主键，通过主键索引效率很高。但是辅助索引需要两次查询，先查询到主键，然后再通过主键查询到数据。因此，主键不应该过大，因为主键太大，其他索引也都会很大。而 MyISAM 是非聚集索引，数据文件是分离的，索引保存的是数据文件的指针。主键索引和辅助索引是独立的。 
4. InnoDB 不保存表的具体行数，执行 select count(*) from table 时需要全表扫描。而MyISAM 用一个变量保存了整个表的行数，执行上述语句时只需要读出该变量即可，速度很快；    
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。这也是 MySQL 将默认存储引擎从 MyISAM 变成 InnoDB 的重要原因之一；
```

#### 聚簇索引和非聚簇索引

```c
聚簇索引：将数据存储与索引放到了一块，找到索引也就找到了数据
非聚簇索引：(二级索引)将数据存储于索引分开结构，索引结构的叶子节点指向了数据的对应行，myisam通过key_buffer把索引先缓存到内存中，当需要访问数据时（通过索引访问数据），在内存中直接搜索索引，然后通过索引找到磁盘相应数据，这也就是为什么索引不在key buffer命中时，速度慢的原因。
    
```

![image-20210317091449776](C:\Users\cheny\AppData\Roaming\Typora\typora-user-images\image-20210317091449776.png)

#### 聚集索引和非聚集索引

```c
    聚集索引是指数据库表行中数据的物理顺序与键值的逻辑（索引）顺序相同。一个表只能有一个聚集索引，因为一个表的物理顺序只有一种情况，所以，对应的聚集索引只能有一个。如果某索引不是聚集索引，则表中的行物理顺序与索引顺序不匹配，与非聚集索引相比，聚集索引有着更快的检索速度。
        MyISAM 引擎（非聚集索引方式， 可以有多个） INNODB聚集索引
```

#### MySQL都有哪些索引类型

```
普通索引，唯一索引，主索引，外建索引，全文索引，多列索引
```

#### 如何设计索引

```
a.最适合索引的列是出现在 WHERE子句中的列，或连接子句中指定的列，而不是出现在 SELECT 关键字后的选择列表中的列。
使用惟一索引。考虑某列中值的分布。索引的列的基数越大，索引的效果越好。
b.如果对字符串列进行索引，应该指定一个前缀长度，只要有可能就应该这样做.
c.利用最左前缀。
d.不要过度索引。
e.考虑最常用的查询。
```

#### mysql主从复制

```
a.异步复制（Asynchronous replication）
	MySQL默认的复制即是异步的，主库在执行完客户端提交的事务后会立即将结果返给给客户端，并不关心从库是否已经接收并处理，这样就会有一个问题，主如果crash掉了，此时主上已经提交的事务可能并没有传到从上，如果此时，强行将从提升为主，可能导致新主上的数据不完整。
b.全同步复制（Fully synchronous replication）
	指当主库执行完一个事务，所有的从库都执行了该事务才返回给客户端。因为需要等待所有从库执行完该事务才能返回，所以全同步复制的性能必然会收到严重的影响。
c.半同步复制（Semisynchronous replication）
	介于异步复制和全同步复制之间，主库在执行完客户端提交的事务后不是立刻返回给客户端，而是等待至少一个从库接收到并写到relay log中才返回给客户端。相对于异步复制，半同步复制提高了数据的安全性，同时它也造成了一定程度的延迟，这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用。
```

#### mvvc

```
用于数据库控制 主要是读已提交和可重复读
对于一次查询生成read-view(包括最大事务id，最小事务id，未提交事务数组),然后找undo记录，如果查询事务id<最小事务id，说明提交了可以查询，如果>最大，说明不能查，如果在之间，查查有没有，没有就可读，一条一条往下找，知道找到可以的undo记录。读出来数据。
```

#### mysql日志

```
binlog 是Mysql Service层记录的日志，undolog、redolog 是InnoDB引擎记录的日志，用以来支持事务。
binlog 记录了生效的sql语句，用于主从同步和回滚
redo log记录数据修改后的值，无论是否提交都记录，用来宕机回复 保证持久性
undo log用于事务 保证原子性 mvvc
```

#### 为什么innodb不用hash

```
a.使用hash表 选择一个好的hash函数比较困难
b.hash范围查询较差
c.hash需要大量内存
```

#### 为什么用B+而不是二叉树avl或其他

```
a.只有两个分支 层数太高
```

#### 常见关键词

```
回表 索引覆盖 最早匹配 索引下推（本来需要查询过滤，现在下推到存储引擎，一次查表就可以得到数据）
```

#### 数据库结构层次

```
client - 连接器 - 分析器 - 优化器 - 执行器 - 储存引擎
```

MySQL的默认隔离级别是RR,但是却没有幻读的问题，那他是怎么解决的呢？答案就是Gap锁。

序列化会锁住整个表